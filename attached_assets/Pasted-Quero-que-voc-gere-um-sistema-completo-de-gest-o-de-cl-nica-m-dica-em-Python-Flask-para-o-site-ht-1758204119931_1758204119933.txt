Quero que você gere um sistema completo de gestão de clínica médica em Python + Flask para o site https://clinicadrraimundonunes.com.br/
. Siga estas instruções estritas:

Acesso à identidade visual

Antes de gerar código, acesse o site acima e extraia automaticamente: logotipo (SVG/PNG), paleta de cores, fontes web usadas, espaçamentos e estilo de botões/inputs. Aplique exatamente a mesma identidade visual (cores e fontes) nos templates Bootstrap/Tailwind ou CSS customizado.

Stack e arquitetura

Backend: Python 3.11+, Flask (blueprints), Flask-Login, Flask-Migrate, Flask-WTF, Flask-Mail (ou alternativa para envio), SQLAlchemy (ORM).

Banco de dados: PostgreSQL (modo produção), com um sqlite local para desenvolvimento.

Autenticação: JWT para API, sessões seguras para painel web, hash de senhas (bcrypt/argon2).

Frontend: Jinja2 templates + Tailwind CSS (configurado para seguir identidade visual) — criar componentes reutilizáveis (Card, Button, Input, Modal).

API RESTful + endpoints JSON para integração com apps móveis.

Dockerfile + docker-compose (db, web) e instruções para deploy no Replit e Railway/Render.

Funcionalidades essenciais (priorize agendamento rápido)

Fluxo de agendamento em 3 passos (ideal):

Cliente escolhe especialidade (ou pesquisa por médico).

Escolhe médico (lista com foto, nota e próximas disponibilidades) — sistema sugere próximos 3 horários livres (1 clique por horário).

Confirmação: nome, telefone (celular), e-mail (pref. por 1-click — sem cadastro obrigatório). Envie OTP por SMS ou e-mail para confirmar (configurar Twilio/SMTP; use um mock/sandbox por padrão).

Permitir agendamento como convidado (mínimos campos) e opção de criar conta para histórico.

Tela de finalização com opção de adicionar ao Google Calendar / iCal (link ICS).

Notificações automáticas: lembrete por e-mail e SMS — 24h e 1h antes.

Regras de agenda: tempo de consulta configurável por especialidade, bloqueios, feriados, intervalo entre consultas.

Painel administrativo (médicos/funcionários):

Visualização de agenda diária/semana/mês com drag & drop para reagendamento.

Aprovação/opção de confirmar agendamentos (workflow: agendado → confirmado → realizado/cancelado).

Lista de espera: quando um horário é cancelado, sistema oferece notificação automática aos primeiros da fila.

Perfis de médicos com foto, CRM, especialidades, horários, bio e convênios aceitos.

Pacote de teleconsulta: gerar link seguro e único (Room) apenas quando confirmado — integração com Jitsi ou WebRTC (fallback).

Pagamentos (opcional): integração com gateway local (ex.: PagSeguro / Gerencianet) e suporte a Pix — gerar comprovante.

Base de dados — esquema sugerido (crie migrations)

users (id, nome, email, telefone, senha_hash, role [admin, staff, medico, paciente], created_at)

medicos (id, user_id, crm, especialidades [m2m], bio, foto_url, ativo)

especialidades (id, nome, descricao)

agendas (id, medico_id, data, hora_inicio, hora_fim, duracao_minutos, tipo [presencial/teleconsulta])

agendamentos (id, paciente_id (nullable para convidado), nome_convidado, email, telefone, medico_id, especialidade_id, inicio, fim, status, origem [site/mobile], reservado_ate)

disponibilidade_excecoes (feriados, folgas)

notificacoes (id, agendamento_id, tipo, enviado_em, status)

pagamentos (id, agendamento_id, metodo, status, valor, transacao_id)

logs_audit (ações críticas: criação/alteração/cancelamento)

Endpoints principais (documente com Swagger/OpenAPI)

POST /api/availability — retorna próximos horários livres por médico/especialidade.

POST /api/book — cria agendamento (convidado ou usuário). Retorna token de confirmação.

POST /api/confirm — confirma com OTP.

GET /api/appointments — para usuário autenticado ou admin (filtrável).

POST /api/cancel — cancelamento com regras (prazos).

Endpoints admin para CRUD de médicos, especialidades, feriados, etc.

Experiência do usuário — foco rapidez

Tela de agendamento responsiva com autofill para dados do usuário (quando autenticado).

Mostrar apenas 3 cliques até a confirmação: especialidade → médico → horário → confirmar (um clique).

Use um componente de sugestão inteligente (pesquisa instantânea) que filtre médicos por nome, especialidade, dia e convênio.

Feedback imediato: loading skeletons, toasts de sucesso/erro, validação inline.

Se o cliente é novo, salvar um cookie com dados básicos para agilizar futuros agendamentos.

Segurança & conformidade

Proteja dados pessoais conforme LGPD: campo para consentimento, política de privacidade, logs de acesso e possibilidade de exclusão de dados (right to be forgotten).

CSRF, rate limiting (ex.: 10 tentativas OTP por hora por IP), validação sanitizada de inputs, prepared statements (ORM) e gerenciamento de segredos via variáveis de ambiente.

Armazenamento seguro de senhas (bcrypt/argon2) e tokens com expiração curta.

Testes, documentação e QA

Unit tests (pytest) cobrindo modelos, validações e lógica de agendamento.

End-to-end tests com Playwright ou Selenium para fluxo de agendamento.

Documentação técnica (README) com instruções de setup local, variáveis de ambiente, comandos Docker e deploy no Replit.

Gerar Postman collection e docs Swagger UI.

Entrega — estrutura de pastas e arquivos

app/ (blueprints: auth, appointments, admin, api)

migrations/

templates/ (Jinja2, components)

static/ (css gerado, imgs, logo extraído do site)

tests/

Dockerfile, docker-compose.yml, Procfile, replit.nix (se aplicável)

scripts/seed_data.py (gera médicos e agendamentos de exemplo)

Critérios de aceitação (o que eu espero receber)

Aplicação rodando localmente via docker-compose up e também instruções para executar direto no Replit.

Fluxo de agendamento funcional sem cadastro em até 3 cliques.

Painel admin com visão de agenda e CRUD de médicos.

Envio de e-mail de confirmação e lembretes por e-mail (ou mock env).

Documentação completa e testes básicos passando.

Solicitações finais para o agente Replit AI

Forneça o código completo em um repositório Replit pronto para rodar.

No primeiro commit, gere todos os arquivos essenciais (migrations vazias, README, .env.example).

Em seguida, crie um segundo commit com dados de exemplo (seed).

Ao finalizar, gere um tutorial passo a passo (em português) para: configurar variáveis de ambiente no Replit, conectar um banco PostgreSQL externo, configurar envio de SMS (Twilio sandbox) e integrar Google Calendar.

Gere também um checklist de pré-lançamento com pontos de segurança e conformidade LGPD.

Use boas práticas de engenharia de software, código limpo e comentários nas partes complexas. Priorize velocidade do agendamento na UX acima de extras não essenciais.